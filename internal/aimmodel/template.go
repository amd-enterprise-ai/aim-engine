// MIT License
//
// Copyright (c) 2025 Advanced Micro Devices, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package aimmodel

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	aimv1alpha1 "github.com/amd-enterprise-ai/aim-engine/api/v1alpha1"
	"github.com/amd-enterprise-ai/aim-engine/internal/aimservicetemplate"
	"github.com/amd-enterprise-ai/aim-engine/internal/constants"
	"github.com/amd-enterprise-ai/aim-engine/internal/utils"
)

// templateBuilderOutputs contains the common parts built by buildTemplateComponents
type templateBuilderOutputs struct {
	Name   string
	Labels map[string]string
	Spec   aimv1alpha1.AIMServiceTemplateSpecCommon
}

// buildTemplateComponents builds the common components (name, labels, spec) for a service template
func buildTemplateComponents(modelName string, modelSpec aimv1alpha1.AIMModelSpec, deployment aimv1alpha1.RecommendedDeployment) templateBuilderOutputs {
	// Generate template name using the specified format (includes modelName in hash for uniqueness)
	templateName := aimservicetemplate.GenerateTemplateName(modelName, modelSpec.Image, deployment)

	// Build common spec
	commonSpec := aimv1alpha1.AIMServiceTemplateSpecCommon{
		ModelName:          modelName,
		ImagePullSecrets:   modelSpec.ImagePullSecrets,
		ServiceAccountName: modelSpec.ServiceAccountName,
	}

	// Set runtime parameters from deployment
	if deployment.Metric != "" {
		metric := aimv1alpha1.AIMMetric(deployment.Metric)
		commonSpec.Metric = &metric
	}
	if deployment.Precision != "" {
		precision := aimv1alpha1.AIMPrecision(deployment.Precision)
		commonSpec.Precision = &precision
	}
	if deployment.GPUModel != "" && deployment.GPUCount > 0 {
		commonSpec.Hardware = &aimv1alpha1.AIMHardwareRequirements{
			GPU: &aimv1alpha1.AIMGpuRequirements{
				Requests: deployment.GPUCount,
				Model:    deployment.GPUModel,
			},
		}
	}

	// Common labels
	labels := map[string]string{
		constants.LabelKeyModel:  modelName,
		constants.LabelKeyOrigin: constants.LabelValueOriginAutoGenerated,
	}

	return templateBuilderOutputs{
		Name:   templateName,
		Labels: labels,
		Spec:   commonSpec,
	}
}

// buildClusterServiceTemplate creates a cluster-scoped service template from model and deployment info.
func buildClusterServiceTemplate(
	model *aimv1alpha1.AIMClusterModel,
	deployment aimv1alpha1.RecommendedDeployment,
) *aimv1alpha1.AIMClusterServiceTemplate {
	components := buildTemplateComponents(model.Name, model.Spec, deployment)
	return &aimv1alpha1.AIMClusterServiceTemplate{
		ObjectMeta: metav1.ObjectMeta{
			Name:   components.Name,
			Labels: components.Labels,
		},
		Spec: aimv1alpha1.AIMClusterServiceTemplateSpec{
			AIMServiceTemplateSpecCommon: components.Spec,
		},
	}
}

// buildServiceTemplate creates a namespace-scoped service template from model and deployment info.
func buildServiceTemplate(
	model *aimv1alpha1.AIMModel,
	deployment aimv1alpha1.RecommendedDeployment,
) *aimv1alpha1.AIMServiceTemplate {
	components := buildTemplateComponents(model.Name, model.Spec, deployment)
	return &aimv1alpha1.AIMServiceTemplate{
		ObjectMeta: metav1.ObjectMeta{
			Name:      components.Name,
			Namespace: model.Namespace,
			Labels:    components.Labels,
		},
		Spec: aimv1alpha1.AIMServiceTemplateSpec{
			AIMServiceTemplateSpecCommon: components.Spec,
		},
	}
}

// ============================================================================
// CUSTOM TEMPLATE BUILDERS
// ============================================================================

// buildCustomServiceTemplates creates namespace-scoped service templates from custom template definitions.
// If no customTemplates are defined but modelSources exist, a single template is auto-generated.
func buildCustomServiceTemplates(model *aimv1alpha1.AIMModel) []*aimv1alpha1.AIMServiceTemplate {
	customTemplates := model.Spec.CustomTemplates
	if len(customTemplates) == 0 {
		// No custom templates defined - create single auto-generated template
		return []*aimv1alpha1.AIMServiceTemplate{
			buildAutoGeneratedCustomTemplate(model),
		}
	}

	templates := make([]*aimv1alpha1.AIMServiceTemplate, 0, len(customTemplates))
	for i := range customTemplates {
		template := buildCustomServiceTemplate(model, &customTemplates[i], i)
		templates = append(templates, template)
	}
	return templates
}

// getCustomHardware safely returns custom.hardware, handling nil custom.
func getCustomHardware(spec *aimv1alpha1.AIMModelSpec) *aimv1alpha1.AIMHardwareRequirements {
	if spec.Custom == nil {
		return nil
	}
	return spec.Custom.Hardware
}

// getCustomType safely returns custom.type, handling nil custom.
func getCustomType(spec *aimv1alpha1.AIMModelSpec) *aimv1alpha1.AIMProfileType {
	if spec.Custom == nil {
		return nil
	}
	return spec.Custom.Type
}

// buildAutoGeneratedCustomTemplate creates a single template when modelSources are set but no customTemplates.
func buildAutoGeneratedCustomTemplate(model *aimv1alpha1.AIMModel) *aimv1alpha1.AIMServiceTemplate {
	templateName := generateCustomTemplateName(model.Name, nil, 0)

	labels := map[string]string{
		constants.LabelKeyModel:  model.Name,
		constants.LabelKeyOrigin: constants.LabelValueOriginAutoGenerated,
	}

	effectiveType := GetEffectiveType(getCustomType(&model.Spec), "")

	// Build the common spec and set embedded fields
	commonSpec := aimv1alpha1.AIMServiceTemplateSpecCommon{
		ModelName:          model.Name,
		ModelSources:       model.Spec.ModelSources,
		ImagePullSecrets:   model.Spec.ImagePullSecrets,
		ServiceAccountName: model.Spec.ServiceAccountName,
		Type:               &effectiveType,
	}
	// Use custom.hardware requirements
	if hw := getCustomHardware(&model.Spec); hw != nil {
		commonSpec.Hardware = hw
		if hw.CPU != nil {
			commonSpec.Resources = cpuRequirementsToResources(hw.CPU)
		}
	}

	return &aimv1alpha1.AIMServiceTemplate{
		ObjectMeta: metav1.ObjectMeta{
			Name:      templateName,
			Namespace: model.Namespace,
			Labels:    labels,
		},
		Spec: aimv1alpha1.AIMServiceTemplateSpec{
			AIMServiceTemplateSpecCommon: commonSpec,
			Env:                          model.Spec.Env,
		},
	}
}

// buildCustomServiceTemplate creates a namespace-scoped template from a custom template definition.
func buildCustomServiceTemplate(
	model *aimv1alpha1.AIMModel,
	customTemplate *aimv1alpha1.AIMCustomTemplate,
	index int,
) *aimv1alpha1.AIMServiceTemplate {
	// Generate template name using consistent naming pattern
	templateName := generateCustomTemplateName(model.Name, customTemplate, index)

	// Merge hardware (template overrides custom.hardware defaults)
	mergedHardware := MergeHardware(getCustomHardware(&model.Spec), customTemplate.Hardware)

	// Merge env vars (template env takes precedence)
	mergedEnv := utils.MergeEnvVars(model.Spec.Env, customTemplate.Env)

	labels := map[string]string{
		constants.LabelKeyModel:  model.Name,
		constants.LabelKeyOrigin: constants.LabelValueOriginAutoGenerated,
	}
	// Add short-hand template alias label if provided
	if customTemplate.Name != "" {
		labels[constants.LabelKeyTemplateAlias] = customTemplate.Name
	}

	effectiveType := GetEffectiveType(getCustomType(&model.Spec), customTemplate.Type)

	// Add short-hand template alias label if provided
	if customTemplate.Name != "" {
		labels[constants.LabelKeyTemplateAlias] = customTemplate.Name
	}

	// Build the common spec and set embedded fields
	commonSpec := aimv1alpha1.AIMServiceTemplateSpecCommon{
		ModelName:          model.Name,
		ModelSources:       model.Spec.ModelSources,
		ImagePullSecrets:   model.Spec.ImagePullSecrets,
		ServiceAccountName: model.Spec.ServiceAccountName,
		Type:               &effectiveType,
	}
	// Use merged hardware requirements
	if mergedHardware != nil {
		commonSpec.Hardware = mergedHardware
		if mergedHardware.CPU != nil {
			commonSpec.Resources = cpuRequirementsToResources(mergedHardware.CPU)
		}
	}

	// Set runtime parameters from profile if provided
	if customTemplate.Profile != nil {
		if customTemplate.Profile.Metric != "" {
			m := customTemplate.Profile.Metric
			commonSpec.Metric = &m
		}
		if customTemplate.Profile.Precision != "" {
			p := customTemplate.Profile.Precision
			commonSpec.Precision = &p
		}
	}

	return &aimv1alpha1.AIMServiceTemplate{
		ObjectMeta: metav1.ObjectMeta{
			Name:      templateName,
			Namespace: model.Namespace,
			Labels:    labels,
		},
		Spec: aimv1alpha1.AIMServiceTemplateSpec{
			AIMServiceTemplateSpecCommon: commonSpec,
			Env:                          mergedEnv,
		},
	}
}

// buildCustomClusterServiceTemplates creates cluster-scoped service templates from custom template definitions.
func buildCustomClusterServiceTemplates(model *aimv1alpha1.AIMClusterModel) []*aimv1alpha1.AIMClusterServiceTemplate {
	customTemplates := model.Spec.CustomTemplates
	if len(customTemplates) == 0 {
		// No custom templates defined - create single auto-generated template
		return []*aimv1alpha1.AIMClusterServiceTemplate{
			buildAutoGeneratedCustomClusterTemplate(model),
		}
	}

	templates := make([]*aimv1alpha1.AIMClusterServiceTemplate, 0, len(customTemplates))
	for i := range customTemplates {
		template := buildCustomClusterServiceTemplate(model, &customTemplates[i], i)
		templates = append(templates, template)
	}
	return templates
}

// buildAutoGeneratedCustomClusterTemplate creates a single cluster template when modelSources are set but no customTemplates.
func buildAutoGeneratedCustomClusterTemplate(model *aimv1alpha1.AIMClusterModel) *aimv1alpha1.AIMClusterServiceTemplate {
	templateName := generateCustomTemplateName(model.Name, nil, 0)

	labels := map[string]string{
		constants.LabelKeyModel:  model.Name,
		constants.LabelKeyOrigin: constants.LabelValueOriginAutoGenerated,
	}

	effectiveType := GetEffectiveType(getCustomType(&model.Spec), "")

	// Build the common spec and set embedded fields
	commonSpec := aimv1alpha1.AIMServiceTemplateSpecCommon{
		ModelName:          model.Name,
		ModelSources:       model.Spec.ModelSources,
		ImagePullSecrets:   model.Spec.ImagePullSecrets,
		ServiceAccountName: model.Spec.ServiceAccountName,
		Type:               &effectiveType,
	}
	// Use custom.hardware requirements
	if hw := getCustomHardware(&model.Spec); hw != nil {
		commonSpec.Hardware = hw
		if hw.CPU != nil {
			commonSpec.Resources = cpuRequirementsToResources(hw.CPU)
		}
	}

	return &aimv1alpha1.AIMClusterServiceTemplate{
		ObjectMeta: metav1.ObjectMeta{
			Name:   templateName,
			Labels: labels,
		},
		Spec: aimv1alpha1.AIMClusterServiceTemplateSpec{
			AIMServiceTemplateSpecCommon: commonSpec,
		},
	}
}

// buildCustomClusterServiceTemplate creates a cluster-scoped template from a custom template definition.
func buildCustomClusterServiceTemplate(
	model *aimv1alpha1.AIMClusterModel,
	customTemplate *aimv1alpha1.AIMCustomTemplate,
	index int,
) *aimv1alpha1.AIMClusterServiceTemplate {
	// Generate template name using consistent naming pattern
	templateName := generateCustomTemplateName(model.Name, customTemplate, index)

	mergedHardware := MergeHardware(getCustomHardware(&model.Spec), customTemplate.Hardware)

	labels := map[string]string{
		constants.LabelKeyModel:  model.Name,
		constants.LabelKeyOrigin: constants.LabelValueOriginAutoGenerated,
	}
	// Add short-hand template alias label if provided
	if customTemplate.Name != "" {
		labels[constants.LabelKeyTemplateAlias] = customTemplate.Name
	}

	effectiveType := GetEffectiveType(getCustomType(&model.Spec), customTemplate.Type)

	// Add short-hand template alias label if provided
	if customTemplate.Name != "" {
		labels[constants.LabelKeyTemplateAlias] = customTemplate.Name
	}

	// Build the common spec and set embedded fields
	commonSpec := aimv1alpha1.AIMServiceTemplateSpecCommon{
		ModelName:          model.Name,
		ModelSources:       model.Spec.ModelSources,
		ImagePullSecrets:   model.Spec.ImagePullSecrets,
		ServiceAccountName: model.Spec.ServiceAccountName,
		Type:               &effectiveType,
	}
	// Use merged hardware requirements
	if mergedHardware != nil {
		commonSpec.Hardware = mergedHardware
		if mergedHardware.CPU != nil {
			commonSpec.Resources = cpuRequirementsToResources(mergedHardware.CPU)
		}
	}

	// Set runtime parameters from profile if provided
	if customTemplate.Profile != nil {
		if customTemplate.Profile.Metric != "" {
			m := customTemplate.Profile.Metric
			commonSpec.Metric = &m
		}
		if customTemplate.Profile.Precision != "" {
			p := customTemplate.Profile.Precision
			commonSpec.Precision = &p
		}
	}

	return &aimv1alpha1.AIMClusterServiceTemplate{
		ObjectMeta: metav1.ObjectMeta{
			Name:   templateName,
			Labels: labels,
		},
		Spec: aimv1alpha1.AIMClusterServiceTemplateSpec{
			AIMServiceTemplateSpecCommon: commonSpec,
		},
	}
}

// cpuRequirementsToResources converts AIMCpuRequirements to corev1.ResourceRequirements.
func cpuRequirementsToResources(cpu *aimv1alpha1.AIMCpuRequirements) *corev1.ResourceRequirements {
	resources := &corev1.ResourceRequirements{
		Requests: corev1.ResourceList{
			corev1.ResourceCPU: cpu.Requests,
		},
	}
	if cpu.Limits != nil {
		resources.Limits = corev1.ResourceList{
			corev1.ResourceCPU: *cpu.Limits,
		}
	}
	return resources
}

// generateCustomTemplateName generates a name for a custom template.
// Uses utils.GenerateDerivedName for consistent naming with proper sanitization and hash suffix.
// Format: {modelName}-custom[-{name}][-{precision}][-{gpu}]-{hash}
func generateCustomTemplateName(modelName string, customTemplate *aimv1alpha1.AIMCustomTemplate, index int) string {
	// Build name parts
	nameParts := []string{modelName, "custom"}

	if customTemplate != nil {
		// Add user-provided name if set
		if customTemplate.Name != "" {
			nameParts = append(nameParts, customTemplate.Name)
		}

		if customTemplate.Profile != nil {
			if customTemplate.Profile.Precision != "" {
				nameParts = append(nameParts, string(customTemplate.Profile.Precision))
			}
		}

		if customTemplate.Hardware != nil && customTemplate.Hardware.GPU != nil {
			if customTemplate.Hardware.GPU.Model != "" {
				nameParts = append(nameParts, customTemplate.Hardware.GPU.Model)
			}
		}
	}

	// Build hash inputs for uniqueness (includes index for multiple templates)
	hashInputs := []any{modelName, index}
	if customTemplate != nil {
		hashInputs = append(hashInputs, customTemplate.Name)
		if customTemplate.Profile != nil {
			hashInputs = append(hashInputs, customTemplate.Profile.Precision, customTemplate.Profile.Metric)
		}
		if customTemplate.Hardware != nil && customTemplate.Hardware.GPU != nil {
			hashInputs = append(hashInputs, customTemplate.Hardware.GPU.Requests, customTemplate.Hardware.GPU.Model)
		}
	}

	name, _ := utils.GenerateDerivedName(nameParts, utils.WithHashSource(hashInputs...))
	return name
}
